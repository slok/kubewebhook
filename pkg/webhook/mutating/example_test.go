package mutating_test

import (
	"context"

	opentracing "github.com/opentracing/opentracing-go"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/slok/kubewebhook/pkg/log"
	"github.com/slok/kubewebhook/pkg/webhook/mutating"
)

// PodAnnotateMutatingWebhook shows how you would create a pod mutating webhook that adds
// annotations to every pod received.
func ExampleMutator_podAnnotateMutatingWebhook() {
	// Annotations to add.
	annotations := map[string]string{
		"mutated":   "true",
		"example":   "ExamplePodAnnotateMutatingWebhook",
		"framework": "kubewebhook",
	}
	// Create our mutator that will add annotations to every pod.
	pam := mutating.MutatorFunc(func(_ context.Context, obj metav1.Object) (bool, error) {
		pod, ok := obj.(*corev1.Pod)
		if !ok {
			return false, nil
		}

		// Mutate our object with the required annotations.
		if pod.Annotations == nil {
			pod.Annotations = make(map[string]string)
		}

		for k, v := range annotations {
			pod.Annotations[k] = v
		}

		return false, nil
	})

	// Create webhook (usage of webhook not in this example).
	cfg := mutating.WebhookConfig{
		Name: "podAnnotateMutatingWebhook",
		Obj:  &corev1.Pod{},
	}
	mutating.NewWebhook(cfg, pam, nil, nil, nil)
}

// chainMutatingWebhook shows how you would create a mutator chain.
func ExampleMutator_chainMutatingWebhook() {

	fakeMut := mutating.MutatorFunc(func(_ context.Context, obj metav1.Object) (bool, error) {
		return false, nil
	})

	fakeMut2 := mutating.MutatorFunc(func(_ context.Context, obj metav1.Object) (bool, error) {
		return false, nil
	})

	fakeMut3 := mutating.MutatorFunc(func(_ context.Context, obj metav1.Object) (bool, error) {
		return false, nil
	})

	// Create a mutator that is a chain of multiple mutators.
	mutChain := mutating.NewChain(log.Dummy, fakeMut, fakeMut2, fakeMut3)

	// Create webhook (usage of webhook not in this example).
	cfg := mutating.WebhookConfig{
		Name: "podWebhook",
		Obj:  &corev1.Pod{},
	}

	mutating.NewWebhook(cfg, mutChain, nil, nil, nil)
}

// TracedMutatingWebhook shows how you would create a mutating webhook that
// can be traced and also traces the webhook mutators with Opentracing.
func ExampleMutator_tracedMutatingWebhook() {
	// Fake the tracer with a noop tracer (this should be the
	// Opentracing tracer implementation).
	tracer := &opentracing.NoopTracer{}

	fakeMut := mutating.MutatorFunc(func(_ context.Context, obj metav1.Object) (bool, error) {
		return false, nil
	})

	// This is optional, if you don't wrap the mutator with a tracing mutator
	// the trace generated by the webhook will not trace the internal chain of
	// mutators, in this case the chain is only this mutator.
	tracedFakeMut := mutating.TraceMutator(tracer, "fakeMutator", fakeMut)

	// Create webhook (usage of webhook not in this example).
	cfg := mutating.WebhookConfig{
		Name: "podWebhook",
		Obj:  &corev1.Pod{},
	}

	// Passing a valid tracer  will trace all the reviews handled by the webhook.
	mutating.NewWebhook(cfg, tracedFakeMut, tracer, nil, nil)
}

package validating_test

import (
	"context"
	"fmt"
	"regexp"

	opentracing "github.com/opentracing/opentracing-go"
	corev1 "k8s.io/api/core/v1"
	extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/slok/kubewebhook/pkg/log"
	"github.com/slok/kubewebhook/pkg/webhook/validating"
)

// IngressHostValidatingWebhook shows how you would create a ingress validating webhook that checks
// if an ingress has any rule with an invalid host that doesn't match the valid host regex and if is invalid
// will not accept the ingress.
func ExampleValidator_ingressHostValidatingWebhook() {
	// Create the regex to validate the hosts.
	validHost := regexp.MustCompile(`^.*\.batman\.best\.superhero\.io$`)

	// Create our validator that will check the host on each rule of the received ingress to
	// allow or disallow the ingress.
	ivh := validating.ValidatorFunc(func(_ context.Context, obj metav1.Object) (bool, validating.ValidatorResult, error) {
		ingress, ok := obj.(*extensionsv1beta1.Ingress)

		if !ok {
			return false, validating.ValidatorResult{}, fmt.Errorf("not an ingress")
		}

		for _, r := range ingress.Spec.Rules {
			if !validHost.MatchString(r.Host) {
				res := validating.ValidatorResult{
					Valid:   false,
					Message: fmt.Sprintf("%s ingress host doesn't match %s regex", r.Host, validHost),
				}
				return false, res, nil
			}
		}

		res := validating.ValidatorResult{
			Valid:   true,
			Message: "all hosts in the ingress are valid",
		}
		return false, res, nil
	})

	// Create webhook (usage of webhook not in this example).
	cfg := validating.WebhookConfig{
		Name: "example",
		Obj:  &extensionsv1beta1.Ingress{},
	}
	validating.NewWebhook(cfg, ivh, nil, nil, nil)
}

// chainValidatingWebhook shows how you would create a validating chain.
func ExampleValidator_chainValidatingWebhook() {
	fakeVal := validating.ValidatorFunc(func(_ context.Context, obj metav1.Object) (bool, validating.ValidatorResult, error) {
		return false, validating.ValidatorResult{}, nil
	})

	fakeVal2 := validating.ValidatorFunc(func(_ context.Context, obj metav1.Object) (bool, validating.ValidatorResult, error) {
		return false, validating.ValidatorResult{}, nil
	})

	fakeVal3 := validating.ValidatorFunc(func(_ context.Context, obj metav1.Object) (bool, validating.ValidatorResult, error) {
		return false, validating.ValidatorResult{}, nil
	})

	// Create a validator that is a chain of multiple validators.
	valChain := validating.NewChain(log.Dummy, fakeVal, fakeVal2, fakeVal3)

	// Create webhook (usage of webhook not in this example).
	cfg := validating.WebhookConfig{
		Name: "podWebhook",
		Obj:  &corev1.Pod{},
	}

	validating.NewWebhook(cfg, valChain, nil, nil, nil)
}

// TracedValidatingWebhook shows how you would create a validating webhook that
// can be traced and also traces the webhook validators with Opentracing.
func ExampleValidator_tracedValidatingWebhook() {
	// Fake the tracer with a noop tracer (this should be the
	// Opentracing tracer implementation).
	tracer := &opentracing.NoopTracer{}

	fakeVal := validating.ValidatorFunc(func(_ context.Context, obj metav1.Object) (bool, validating.ValidatorResult, error) {
		return false, validating.ValidatorResult{}, nil
	})

	// This is optional, if you don't wrap the validator with a tracing validator
	// the trace generated by the webhook will not trace the internal chain of
	// validators, in this case the chain is only this validator.
	tracedFakeVal := validating.TraceValidator(tracer, "fakeValidator", fakeVal)

	// Create webhook (usage of webhook not in this example).
	cfg := validating.WebhookConfig{
		Name: "podWebhook",
		Obj:  &corev1.Pod{},
	}

	// Passing a valid tracer  will trace all the reviews handled by the webhook.
	validating.NewWebhook(cfg, tracedFakeVal, tracer, nil, nil)
}
